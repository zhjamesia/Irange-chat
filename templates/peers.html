<!DOCTYPE html>
<html>
<head>
    <title>PeerJS Chat</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <!-- <script src="./static/peerjs.min.js"></script> -->
    <!-- Add/replace styles for centered fixed-size chat box -->
	<style>
		/* Centered fixed-size chat box */
		.center-wrap { display:block; height:100vh; background:#e5ddd5; }
		.chat-box {
			width:100vw;
			height:100vh;
			border-radius:0;
			box-shadow:0 6px 18px rgba(0,0,0,0.12);
			display:flex;
			flex-direction:column;
			overflow:hidden;
			position:relative; /* needed for overlay positioning */
		}
		.chat-header {
			padding:12px 16px;
			background:#00c853;
			color:#fff;
			font-weight:600;
			display:flex;
			justify-content:space-between;
			align-items:center;
		}
		.chat-area { display:flex; flex:1; min-height:0; } /* min-height:0 needed for flexbox scroll */
		.contacts-pane {
			width:260px;
			border-right:1px solid #eee;
			overflow:auto;
			background:#fafafa;
		}
		.contacts-pane .contact { padding:10px; border-bottom:1px solid #f0f0f0; cursor:pointer; }
		.messages-pane {
			flex:1;
			display:flex;
			flex-direction:column;
			min-width:0;
		}
		.messages {
			padding:16px;
			overflow:auto;
			background:linear-gradient(180deg,#f6f6f6,#eaeaea);
			flex:1;
		}
		.input-bar {
			padding:10px;
			display:flex;
			gap:8px;
			align-items:center;
			border-top:1px solid #eee;
			background:#fff;
		}
		.input-bar textarea { flex:1; resize:none; height:48px; padding:10px; border-radius:8px; border:1px solid #ddd; font-size:14px; }
		.input-bar .file-input {
			display:inline-block;
		}
		.input-bar .btn { background:#00c853; color:#fff; padding:10px 14px; border-radius:8px; border:none; cursor:pointer; }
		/* small image in bubble */
		.msg-img { max-width:260px; border-radius:8px; display:block; }

		/* keep previous wechat-like bubble styles if present */
		.message.me { justify-content:flex-end; }
		.bubble.right { background:#00c853; color:#fff; }
		.bubble.left { background:#fff; color:#111; }

		/* Remote video overlay (overlaps chat until hangup) */
		.remote-overlay {
			/* changed: make overlay cover 80% of screen and center it */
			position: absolute;
			top: 10vh;           /* 10% from top */
			left: 10vw;          /* 10% from left */
			width: 80vw;         /* 80% viewport width */
			height: 80vh;        /* 80% viewport height */
			background: #000;
			border-radius: 8px;
			box-shadow: 0 8px 48px rgba(0,0,0,0.45);
			z-index: 10002;
			display: none;
			overflow: hidden;
		}
		.remote-overlay video {
			width: 100%;
			height: 100%;
			object-fit: contain; /* changed: contain so entire remote video is visible */
			background: #000;
		}

		/* ensure Hang Up button is visible on top of the overlay */
		.remote-overlay .hangup-btn {
			position: absolute;
			top: 12px;
			right: 12px;
			z-index: 10003; /* above the overlay */
			background: rgba(220, 38, 38, 0.95);
			color: #fff;
			border: none;
			padding: 8px 12px;
			border-radius: 6px;
			font-weight: 600;
			cursor: pointer;
			box-shadow: 0 6px 18px rgba(0,0,0,0.25);
		}

		/* Ensure no page-level scrollbars from element overflow */
		html, body {
			height: 100%;
			margin: 0;
			overflow: hidden;
			box-sizing: border-box;
		}
	</style>
</head>
<body>
    <!-- Replace main wechat layout with centered chat-box while preserving contacts and chat area -->
	<div class="center-wrap">
		<div class="chat-box">
			<div class="chat-header">
				<span>Irange Chat</span>
				<small id="myPeerId">...</small>
			</div>

			<!-- add overlay just after header so it's positioned inside the chat container -->
			<div id="remoteOverlay" class="remote-overlay" aria-hidden="true">
				<video id="remoteOverlayVideo" autoplay playsinline></video>
				<button id="hangupBtn" class="hangup-btn">Hang Up</button>
			</div>

			<div class="chat-area">
				<!-- messages pane moved to the LEFT (user requested "on left the msg box") -->
				<div class="messages-pane">
					<!-- Combined input bar: file picker + textarea + single send -->
					<div class="input-bar">
						<input id="imageInput" class="file-input" type="file" accept="image/*">
						<textarea id="messageInput" placeholder="Type a message..."></textarea>
						<button id="sendAll" class="btn">Send</button>
					</div>
					<div id="chatLog" class="messages"></div>

				</div>

				<!-- contacts pane on the RIGHT now; includes join room + camera + call controls -->
				<div class="contacts-pane" id="contacts">
					<!-- new: join controls + camera + call inserted into contacts pane -->
					<div id="roomControls" style="padding:10px;border-bottom:1px solid #eee;">
						<input type="text" id="roomIdLeft" placeholder="Enter Room ID" style="width:80%;padding:6px;border-radius:6px;border:1px solid #ddd;margin-bottom:8px;">
						<button id="joinRoomLeft" class="btn" style="width:100%;margin-bottom:8px;">Join Room</button>

						<!-- camera select visible in the window -->
						<label for="cameraSelect" style="display:block;margin-bottom:6px;font-size:12px;color:#666;">Camera</label>
						<select id="cameraSelect" style="width:100%;padding:6px;border-radius:6px;border:1px solid #ddd;margin-bottom:8px;">
							<option value="">Default camera</option>
						</select>

						<!-- call / answer controls visible in the window -->
						<button id="makeCall" class="btn" style="width:48%;display:inline-block;margin-right:4%;">Call</button>
						<button id="answerCall" class="btn" style="width:48%;display:inline-block;display:none;">Answer</button>
					</div>

					<!-- contacts list rendered below -->
					<div id="contactsList"></div>
				</div>
			</div>
		</div>
	</div>

    <!-- changed: add playsinline and mute local preview so iOS allows autoplay -->
    <video id="localVideo" autoplay playsinline muted></video>
    <canvas id="canvas" style="display:none;"></canvas>

    <script>
        // --- Changed: create peer with modern iceServers ("urls") and debug/error logging ---
        var peer = new Peer({
            secure: true,
            debug: 2,
            config: {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ]
            }
        });

        var roomId = null;
        var users = {};
        var conn;
        var localStream;
        // single global reference to active MediaConnection (set when call is made/answered)
        var activeCall = null;
        var remoteOverlayVideo = document.getElementById('remoteOverlayVideo');
        var localVideo = document.getElementById('localVideo');
        var cameraSelect = document.getElementById('cameraSelect');
        var canvas = document.getElementById('canvas');
        var context = canvas.getContext('2d');

        // New: chat storage and UI helpers
		var messages = {}; // { peerId: [{text, from, isImage, me, ts}, ...] }
		var currentPeer = null;
		var refreshTimer = null;

		function appendMessage(text, from, isImage, me, peerId) {
			peerId = peerId || currentPeer;
			if (!peerId) return;
			messages[peerId] = messages[peerId] || [];
			messages[peerId].push({ text: text, from: from, isImage: !!isImage, me: !!me, ts: Date.now() });
			// only render if the chat with this peer is active
			if (peerId === currentPeer) {
				var messagesDiv = document.getElementById('chatLog');
				// render single message
				var wrapper = document.createElement('div');
				wrapper.className = 'message ' + (me ? 'me' : 'other');
				var bubble = document.createElement('div');
				bubble.className = 'bubble ' + (me ? 'right' : 'left');
				if (isImage) {
					var img = document.createElement('img');
					img.className = 'msg-img';
					img.src = text;
					bubble.appendChild(img);
				} else {
					bubble.textContent = text;
				}
				wrapper.appendChild(bubble);
				var time = document.createElement('div');
				time.className = 'msg-time';
				time.textContent = (from ? (from + ' ') : '') + new Date().toLocaleTimeString();
				wrapper.appendChild(time);
				messagesDiv.appendChild(wrapper);
				messagesDiv.scrollTop = messagesDiv.scrollHeight;
			}
		}

		function renderChat(peerId) {
			currentPeer = peerId;
			var messagesDiv = document.getElementById('chatLog');
			messagesDiv.innerHTML = '';
			if (!peerId) {
				document.getElementById('chatTitle') && (document.getElementById('chatTitle').textContent = 'Select a contact');
				return;
			}
			document.getElementById('chatTitle') && (document.getElementById('chatTitle').textContent = peerId);
			var list = messages[peerId] || [];
			list.forEach(function(m) {
				var wrapper = document.createElement('div');
				wrapper.className = 'message ' + (m.me ? 'me' : 'other');
				var bubble = document.createElement('div');
				bubble.className = 'bubble ' + (m.me ? 'right' : 'left');
				if (m.isImage) {
					var img = document.createElement('img');
					img.className = 'msg-img';
					img.src = m.text;
					bubble.appendChild(img);
				} else {
					bubble.textContent = m.text;
				}
				wrapper.appendChild(bubble);
				var time = document.createElement('div');
				time.className = 'msg-time';
				time.textContent = (m.from ? (m.from + ' ') : '') + new Date(m.ts).toLocaleTimeString();
				wrapper.appendChild(time);
				messagesDiv.appendChild(wrapper);
			});
			messagesDiv.scrollTop = messagesDiv.scrollHeight;
		}

		// Contacts rendering helpers
		var contactsListDiv = document.getElementById('contactsList');

		function renderContacts(peers) {
			contactsListDiv.innerHTML = '';
			peers.forEach(function(id) {
				if (id !== peer.id) {
					addContact(id);
					// restore selected state if this was the currentPeer
					if (currentPeer && id === currentPeer) {
						var sel = contactsListDiv.querySelector('.contact[data-id="'+id+'"]');
						if (sel) sel.classList.add('selected');
					}
				}
			});
		}

		// Replace addContact to reliably set currentPeer and support touch
		function addContact(id) {
			if (contactsListDiv.querySelector('.contact[data-id="'+id+'"]')) return;
			var el = document.createElement('div');
			el.className = 'contact';
			el.dataset.id = id;
			el.innerHTML = '<div class="avatar"></div><div class="meta"><strong>' + id + '</strong><small>Tap to chat</small></div>';

			function selectContact() {
				// highlight selection
				Array.from(contactsListDiv.children).forEach(function(c){ c.classList.remove('selected'); });
				el.classList.add('selected');

				// update hidden select (keeps existing logic compatible)
				var us = document.getElementById('userSelect');
				if (us) us.value = id;

				// authoritative selection used by sendAll and render
				currentPeer = id;
				renderChat(id);
			}

			el.addEventListener('click', selectContact);
			// touchstart improves responsiveness on mobile/touch devices
			el.addEventListener('touchstart', function(evt){
				evt.preventDefault(); // prevent 300ms delay / synthetic mouse events
				selectContact();
			}, { passive:false });

			contactsListDiv.appendChild(el);
		}

        peer.on('error', function(err) {
            console.error('Peer error:', err);
        });

        // Helper: get or create a DataConnection and reuse it (important for iOS/Safari)
        function getOrCreateConnection(userId, cb) {
            if (!userId) return;
            // reuse existing open connection
            if (users[userId] && users[userId].conn && users[userId].conn.open) {
                return cb(users[userId].conn);
            }
            // create a new connection with reliable flag (helps Safari)
            var c = peer.connect(userId, { reliable: true });
            users[userId] = users[userId] || { id: userId };
            users[userId].conn = c;

            c.on('open', function() {
                console.log('Connection open to', userId);
                cb(c);
            });

            c.on('data', function(data) {
                var peerId = c.peer;
                // string data: could be data URL or plain text
                if (typeof data === 'string') {
                    if (data.indexOf('data:') === 0) {
                        // data URL: determine if image or other and handle
                        handleDataUrlString(data, peerId, peerId, false);
                    } else {
                        appendMessage(data, peerId, false, false, peerId);
                    }
                } else if (data instanceof Blob) {
                    // Blob: check mime
                    var mime = data.type || '';
                    if (mime.indexOf('image/') === 0) {
                        var imgUrl = URL.createObjectURL(data);
                        appendMessage(imgUrl, peerId, true, false, peerId);
                    } else {
                        var ext = getExtensionFromMime(mime);
                        var filename = 'file_' + Date.now() + '.' + ext;
                        var url = URL.createObjectURL(data);
                        appendFileLink(url, filename, peerId, false, peerId);
                    }
                } else if (data instanceof ArrayBuffer) {
                    // create blob and offer download
                    var blob = new Blob([data], { type: 'application/octet-stream' });
                    var filename = 'file_' + Date.now() + '.bin';
                    var url = URL.createObjectURL(blob);
                    appendFileLink(url, filename, peerId, false, peerId);
                } else {
                    try {
                        appendMessage(JSON.stringify(data), peerId, false, false, peerId);
                    } catch (e) {
                        appendMessage('Peer sent data', peerId, false, false, peerId);
                    }
                }
            });

            c.on('error', function(err) {
                console.error('Connection error with', userId, err);
            });

            c.on('close', function() {
                console.log('Connection closed to', userId);
                if (users[userId]) delete users[userId].conn;
            });
        }

        // Refresh peers from server and update UI
		function refreshPeersFromServer() {
			if (!roomId) return;
			var xhr = new XMLHttpRequest();
			xhr.open('POST', '/get_peers', true);
			xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
			xhr.send('roomId=' + encodeURIComponent(roomId));
			xhr.onload = function() {
				if (xhr.status === 200) {
					try {
						var peers = JSON.parse(xhr.responseText).peers || [];
						// update left contacts UI
						renderContacts(peers);
						// also update hidden select for backwards compatibility
						var userSelect = document.getElementById('userSelect');
						userSelect.innerHTML = '<option value="">Select a user to chat with</option>';
						peers.forEach(function(peerId) {
							if (peerId !== peer.id) {
								var option = document.createElement('option');
								option.value = peerId;
								option.text = peerId;
								userSelect.add(option);
							}
						});
					} catch (e) { console.warn('Invalid peers response', e); }
				}
			};
		}

        peer.on('open', function(id) {
            console.log('My peer ID is: ' + id);
            users[id] = users[id] || { id: id };
            addContact(id); // optional, shows self in contacts
            document.getElementById('myPeerId').innerHTML = 'My Peer ID: ' + id;
            // if already had roomId (reconnect), refresh peers
            if (roomId) { refreshPeersFromServer(); if (refreshTimer) clearInterval(refreshTimer); refreshTimer = setInterval(refreshPeersFromServer, 10000); }
        });

        document.getElementById('joinRoomLeft').addEventListener('click', function() {
			roomId = document.getElementById('roomIdLeft').value;
			if (!roomId) { alert('Enter a room id'); return; }
			var xhr = new XMLHttpRequest();
			xhr.open('POST', '/join', true);
			xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
			xhr.send('roomId=' + encodeURIComponent(roomId) + '&peerId=' + encodeURIComponent(peer.id));
			xhr.onload = function() {
				if (xhr.status === 200) {
					// start immediate refresh and periodic refresh every 10s
					refreshPeersFromServer();
					if (refreshTimer) clearInterval(refreshTimer);
					refreshTimer = setInterval(refreshPeersFromServer, 10000);
				} else {
					alert('Failed to join room');
				}
			};
		});

		// unified send: prefer currentPeer (explicitly selected contact)
		document.getElementById('sendAll').addEventListener('click', function() {
			// prefer currentPeer first
			var userId = currentPeer || (document.getElementById('userSelect') && document.getElementById('userSelect').value) || '';
			if (!userId) { alert('Select a contact to send to.'); return; }

			var imageInput = document.getElementById('imageInput');
			var messageInput = document.getElementById('messageInput');

			if (imageInput && imageInput.files && imageInput.files.length > 0) {
				var file = imageInput.files[0];
				var reader = new FileReader();
				reader.onload = function() {
					var imageData = reader.result;
					getOrCreateConnection(userId, function(conn) {
						conn.send(imageData);
						// store and render locally
						appendMessage(imageData, 'You', true, true, userId);
						imageInput.value = '';
					});
				};
				reader.readAsDataURL(file);
				return;
			}

			var message = messageInput.value && messageInput.value.trim();
			if (message) {
				getOrCreateConnection(userId, function(conn) {
					conn.send(message);
					appendMessage(message, 'You', false, true, userId);
					messageInput.value = '';
				});
			}
		});

        // New helper: request local media on demand (use user gesture)
        function ensureLocalStream(cb) {
            if (localStream) {
                // if a camera is selected that differs from current stream, recreate
                var selectedId = cameraSelect.value || null;
                var currentDeviceId = null;
                try {
                    var tracks = localStream.getVideoTracks();
                    if (tracks && tracks.length) {
                        // many browsers provide getSettings().deviceId
                        currentDeviceId = tracks[0].getSettings ? tracks[0].getSettings().deviceId : null;
                    }
                } catch (e) { currentDeviceId = null; }

                if (selectedId && currentDeviceId !== selectedId) {
                    // stop old tracks and fall through to request new stream
                    localStream.getTracks().forEach(function(t){ try{ t.stop(); }catch(e){} });
                    localStream = null;
                } else {
                    if (cb) cb(localStream);
                    // try to populate list now that permission granted
                    populateCameraList();
                    return;
                }
            }

            var selectedDeviceId = cameraSelect.value || null;
            var videoConstraints = selectedDeviceId ? { deviceId: { exact: selectedDeviceId } } : { facingMode: 'user' };

            navigator.mediaDevices.getUserMedia({ video: videoConstraints, audio: true })
            .then(function(stream) {
                localStream = stream;
                // stop previously attached srcObject tracks if any (defensive)
                try {
                    localVideo.srcObject = stream;
                    localVideo.muted = true;
                    localVideo.setAttribute('playsinline', '');
                    localVideo.play().catch(function(){ /* ignore autoplay rejection */ });
                } catch (e) {
                    console.warn('Could not set localVideo srcObject:', e);
                }
                // update camera dropdown labels now we have permission
                populateCameraList();
                if (cb) cb(stream);
            })
            .catch(function(err) {
                console.error('getUserMedia error:', err);
                alert('Camera/microphone access is required to make/answer calls.');
                if (cb) cb(null);
            });
        }

        // New: populate available video input devices into cameraSelect
        function populateCameraList() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) return;
            navigator.mediaDevices.enumerateDevices()
            .then(function(devices) {
                var videoInputs = devices.filter(function(d) { return d.kind === 'videoinput'; });
                // preserve current selection
                var current = cameraSelect.value;
                cameraSelect.innerHTML = '<option value="">Default camera</option>';
                videoInputs.forEach(function(device) {
                    var option = document.createElement('option');
                    option.value = device.deviceId;
                    // use label when available (after permission), fallback to deviceId suffix
                    option.text = device.label || ('Camera ' + (cameraSelect.length));
                    cameraSelect.add(option);
                });
                // try to restore selection
                if (current) cameraSelect.value = current;
            })
            .catch(function(err) {
                console.warn('Could not list cameras:', err);
            });
        }

        // When user changes camera selection, re-acquire stream (user gesture recommended)
        cameraSelect.addEventListener('change', function() {
            // attempt to switch camera; this will stop old tracks and request new stream
            ensureLocalStream(function(stream){
                if (!stream) {
                    console.warn('Switch camera failed or permission denied');
                }
            });
        });

        document.getElementById('makeCall').addEventListener('click', function() {
			var selectedUserId = currentPeer || (document.getElementById('userSelect') && document.getElementById('userSelect').value);
			if (!selectedUserId) {
				alert('Select a contact to call.');
				return;
			}
			ensureLocalStream(function(stream) {
				if (!stream) {
					alert('Unable to get local media');
					return;
				}
				var call = peer.call(selectedUserId, stream);
				activeCall = call;
				call.on('stream', function(remoteStream) {
					showRemoteStream(remoteStream);
				});
				call.on('close', function(){ hideRemoteStream(); });
				call.on('error', function(err){ console.error('Call error', err); hideRemoteStream(); });
			});
        });

        // Answer incoming calls only after ensuring we have local media
        var pendingCall = null;
        var answerBtn = document.getElementById('answerCall');

        // Replace incoming call handler to show a confirm popup and optionally auto-answer
        // (replace the existing peer.on('call', ...) block)
        peer.on('call', function(call) {
            console.log('Incoming call from', call.peer);
            // store temporarily so Answer button can still be used if user declines the immediate prompt
            pendingCall = call;

            // show a simple browser confirm popup asking user to accept now
            try {
                var answerNow = confirm('Incoming call from ' + call.peer + '. Answer now?');
            } catch (e) {
                // in some embedded contexts confirm may be blocked; fall back to showing the Answer button
                var answerNow = false;
            }

            if (answerNow) {
                // user accepted; get local media and answer
                ensureLocalStream(function(stream) {
                    if (!stream) {
                        alert('Camera/microphone access required to answer the call.');
                        // keep pendingCall so user may click Answer manually
                        answerBtn.style.display = 'inline-block';
                        return;
                    }
                    try {
                        call.answer(stream);
                    } catch (e) {
                        console.error('Error answering call immediately:', e);
                        answerBtn.style.display = 'inline-block';
                        return;
                    }

                    // set active call and wire handlers
                    activeCall = call;
                    call.on('stream', function(remoteStream) {
                        showRemoteStream(remoteStream);
                    });
                    call.on('close', function() { hideRemoteStream(); });
                    call.on('error', function(err){ console.error('Incoming call error', err); hideRemoteStream(); });

                    // clear pending and hide answer button since we've answered
                    pendingCall = null;
                    answerBtn.style.display = 'none';
                });
            } else {
                // user declined immediate popup — show the UI Answer button as fallback
                answerBtn.style.display = 'inline-block';
                document.getElementById('chatLog').innerHTML += 'Incoming call from ' + call.peer + ' — click Answer to accept<br>';
            }
        });

        // --- Changed: store inbound connections so we can reuse them ---
        peer.on('connection', function(c) {
            // store it
            users[c.peer] = users[c.peer] || { id: c.peer };
            users[c.peer].conn = c;

            c.on('data', function(data) {
                var peerId = c.peer;
				if (typeof data === 'string') {
					if (data.indexOf('data:') === 0) {
						// data URL: convert and handle accordingly
						handleDataUrlString(data, peerId, peerId, false);
					} else {
						appendMessage(data, peerId, false, false, peerId);
					}
				} else if (data instanceof Blob) {
					var mime = data.type || '';
					if (mime.indexOf('image/') === 0) {
						var imgUrl = URL.createObjectURL(data);
						appendMessage(imgUrl, peerId, true, false, peerId);
					} else {
						var ext = getExtensionFromMime(mime);
						var filename = 'file_' + Date.now() + '.' + ext;
						var url = URL.createObjectURL(data);
						appendFileLink(url, filename, peerId, false, peerId);
					}
				} else if (data instanceof ArrayBuffer) {
					var blob = new Blob([data], { type: 'application/octet-stream' });
					var filename = 'file_' + Date.now() + '.bin';
					var url = URL.createObjectURL(blob);
					appendFileLink(url, filename, peerId, false, peerId);
				} else {
					try { appendMessage(JSON.stringify(data), peerId, false, false, peerId); } catch(e){ appendMessage('Peer sent data', peerId, false, false, peerId); }
				}
				// if contact not in list yet, add it
				addContact(peerId);
            });

            c.on('open', function() {
                console.log('Inbound connection open from', c.peer);
                addContact(c.peer);
            });

            c.on('close', function() {
                console.log('Inbound connection closed from', c.peer);
                if (users[c.peer]) delete users[c.peer].conn;
            });

            c.on('error', function(err){
                console.error('Inbound connection error from', c.peer, err);
            });
        });

        // Remove any unconditional navigator.mediaDevices.getUserMedia(...) auto-call at bottom

		// --- Changed: show/hide remote video overlay and handle active call reference ---
		var activeCall = null;

		function showRemoteStream(remoteStream) {
			var overlay = document.getElementById('remoteOverlay');
			overlay.style.display = 'block';
			remoteOverlayVideo.srcObject = remoteStream;
			remoteOverlayVideo.setAttribute('playsinline', '');
			remoteOverlayVideo.play().catch(function(){ /* ignore */ });
		}

		function hideRemoteStream() {
			var overlay = document.getElementById('remoteOverlay');
			overlay.style.display = 'none';
			// clear and stop remote video element
			try {
				if (remoteOverlayVideo && remoteOverlayVideo.srcObject) {
					remoteOverlayVideo.pause();
					remoteOverlayVideo.srcObject = null;
				}
			} catch (e) { /* ignore */ }
			// hide local preview and clear it as user asked not to show local video
			try {
				if (localVideo) { localVideo.style.display = 'none'; localVideo.srcObject = null; }
			} catch (e) {}
			// clear activeCall reference (call will be closed where appropriate)
			activeCall = null;
		}

		document.getElementById('hangupBtn').addEventListener('click', function() {
			if (!activeCall && !pendingCall) return;
			if (!confirm('Hang up the call?')) return;
			// close active media call (PeerJS MediaConnection) if present
			try {
				if (activeCall && typeof activeCall.close === 'function') {
					activeCall.close();
				}
			} catch (e) { console.warn('Error closing active call', e); }
			// also close pending/incoming call if present
			try {
				if (pendingCall && typeof pendingCall.close === 'function') pendingCall.close();
			} catch (e) {}
			// hide overlay and clear video UI
			hideRemoteStream();
		});

		// Hook incoming/outgoing call objects to set activeCall and attach close handler
		// Merge into your makeCall / answer flows:
		// - After var call = peer.call(...): set activeCall = call; attach call.on('close', ...) that calls hideRemoteStream()
		// - After pendingCall.answer(stream): set activeCall = pendingCall; attach same handlers
		// ...existing makeCall and answer code already sets activeCall = call / pendingCall and attaches handlers earlier ...
    </script>

    <!-- ...existing footer/ placeholders ... -->
</body>
</html>
