<!DOCTYPE html>
<html>
<head>
    <title>PeerJS Chat</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <!-- <script src="./static/peerjs.min.js"></script> -->
</head>
<body>
    <h1>PeerJS Chat</h1>
    <input type="text" id="roomId" placeholder="Enter Room ID">
    <button id="joinRoom">Join Room</button>
    <button id="getPeers">Get Peers</button>
    <br><br>
    <select id="userSelect">
        <option value="">Select a user to chat with</option>
    </select>
    <br><br>
    <input type="text" id="messageInput" placeholder="Type a message...">
    <button id="sendMessage">Send</button>
    <input type="file" id="imageInput" accept="image/*">
    <button id="sendImage">Send Image</button>
    <button id="takePicture">Take Picture</button>
    <video id="localVideo" autoplay></video>
    <canvas id="canvas" style="display:none;"></canvas>
    <br><br>
    <button id="makeCall">Call Selected User</button>
    <br><br>
    <video id="remoteVideo" autoplay></video>
    <script>
        var peer;
        var roomId;
        var users = {};
        var conn;
        var localStream;
        var remoteVideo = document.getElementById('remoteVideo');
        var localVideo = document.getElementById('localVideo');
        var canvas = document.getElementById('canvas');
        var context = canvas.getContext('2d');

        // --- Changed: create peer with modern iceServers ("urls") and debug/error logging ---
        peer = new Peer({
            secure: true,
            debug: 2,
            config: {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ]
            }
        });

        peer.on('error', function(err) {
            console.error('Peer error:', err);
        });

        // Helper: get or create a DataConnection and reuse it (important for iOS/Safari)
        function getOrCreateConnection(userId, cb) {
            if (!userId) return;
            // reuse existing open connection
            if (users[userId] && users[userId].conn && users[userId].conn.open) {
                return cb(users[userId].conn);
            }
            // create a new connection with reliable flag (helps Safari)
            var c = peer.connect(userId, { reliable: true });
            users[userId] = users[userId] || { id: userId };
            users[userId].conn = c;

            c.on('open', function() {
                console.log('Connection open to', userId);
                cb(c);
            });

            c.on('data', function(data) {
                // ensure inbound messages on outgoing connections are also handled
                var chatLog = document.getElementById('chatLog');
                if (typeof data === 'string') {
                    if (data.indexOf('data:image/') === 0) {
                        var image = document.createElement('img');
                        image.src = data;
                        image.style.maxWidth = '400px';
                        image.style.display = 'block';
                        chatLog.appendChild(image);
                        chatLog.innerHTML += '<br>';
                    } else {
                        chatLog.innerHTML += 'Peer: ' + data + '<br>';
                    }
                } else if (data instanceof Blob || data instanceof ArrayBuffer) {
                    var url = URL.createObjectURL(data);
                    var image = document.createElement('img');
                    image.src = url;
                    image.style.maxWidth = '400px';
                    image.style.display = 'block';
                    chatLog.appendChild(image);
                    chatLog.innerHTML += '<br>';
                } else {
                    try {
                        chatLog.innerHTML += 'Peer: ' + JSON.stringify(data) + '<br>';
                    } catch (e) {
                        chatLog.innerHTML += 'Peer sent data<br>';
                    }
                }
            });

            c.on('error', function(err) {
                console.error('Connection error with', userId, err);
            });

            c.on('close', function() {
                console.log('Connection closed to', userId);
                if (users[userId]) delete users[userId].conn;
            });
        }

        peer.on('open', function(id) {
            console.log('My peer ID is: ' + id);
            users[id] = users[id] || { id: id };
            var userSelect = document.getElementById('userSelect');
            var option = document.createElement('option');
            option.value = id;
            option.text = id;
            userSelect.add(option);
            document.getElementById('myPeerId').innerHTML = 'My Peer ID: ' + id;
        });

        document.getElementById('joinRoom').addEventListener('click', function() {
            roomId = document.getElementById('roomId').value;
            var xhr = new XMLHttpRequest();
            xhr.open('POST', '/join', true);
            xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
            xhr.send('roomId=' + roomId + '&peerId=' + peer.id);
            xhr.onload = function() {
                if (xhr.status === 200) {
                    console.log(xhr.responseText);
                }
            };
        });

        document.getElementById('getPeers').addEventListener('click', function() {
            roomId = document.getElementById('roomId').value;
            var xhr = new XMLHttpRequest();
            xhr.open('POST', '/get_peers', true);
            xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
            xhr.send('roomId=' + roomId);
            xhr.onload = function() {
                if (xhr.status === 200) {
                    var peers = JSON.parse(xhr.responseText).peers;
                    var userSelect = document.getElementById('userSelect');
                    userSelect.innerHTML = '<option value="">Select a user to chat with</option>';
                    peers.forEach(function(peerId) {
                        if (peerId !== peer.id) {
                            var option = document.createElement('option');
                            option.value = peerId;
                            option.text = peerId;
                            userSelect.add(option);
                        }
                    });
                }
            };
        });

        document.getElementById('sendMessage').addEventListener('click', function() {
            var userId = document.getElementById('userSelect').value;
            var message = document.getElementById('messageInput').value;
            if (userId && message) {
                getOrCreateConnection(userId, function(conn) {
                    conn.send(message);
                    document.getElementById('chatLog').innerHTML += 'You: ' + message + '<br>';
                    document.getElementById('messageInput').value = '';
                });
            }
        });

        document.getElementById('sendImage').addEventListener('click', function() {
            var userId = document.getElementById('userSelect').value;
            var imageInput = document.getElementById('imageInput');
            if (userId && imageInput.files.length > 0) {
                var file = imageInput.files[0];
                var reader = new FileReader();
                reader.onload = function() {
                    var imageData = reader.result;
                    getOrCreateConnection(userId, function(conn) {
                        conn.send(imageData);
                        document.getElementById('chatLog').innerHTML += 'You sent an image<br>';
                    });
                };
                reader.readAsDataURL(file);
            }
        });

        document.getElementById('takePicture').addEventListener('click', function() {
            navigator.mediaDevices.getUserMedia({video: true, audio: false})
            .then(function(stream) {
                localVideo.srcObject = stream;
                localVideo.play();
                var videoTracks = stream.getVideoTracks();
                var track = videoTracks[0];
                // ImageCapture is not supported on all iOS versions â€” fallback to drawing to canvas
                if (typeof ImageCapture !== 'undefined') {
                    var imageCapture = new ImageCapture(track);
                    imageCapture.takePhoto()
                    .then(function(blob) {
                        var userId = document.getElementById('userSelect').value;
                        var reader = new FileReader();
                        reader.onload = function() {
                            var imageData = reader.result;
                            getOrCreateConnection(userId, function(conn) {
                                conn.send(imageData);
                                document.getElementById('chatLog').innerHTML += 'You sent an image<br>';
                            });
                        };
                        reader.readAsDataURL(blob);
                    })
                    .catch(function(error) {
                        console.error('Error taking photo:', error);
                    });
                } else {
                    // fallback: grab a frame from the video into a canvas
                    var userId = document.getElementById('userSelect').value;
                    canvas.width = localVideo.videoWidth || 640;
                    canvas.height = localVideo.videoHeight || 480;
                    context.drawImage(localVideo, 0, 0, canvas.width, canvas.height);
                    canvas.toBlob(function(blob) {
                        var reader = new FileReader();
                        reader.onload = function() {
                            var imageData = reader.result;
                            getOrCreateConnection(userId, function(conn) {
                                conn.send(imageData);
                                document.getElementById('chatLog').innerHTML += 'You sent an image<br>';
                            });
                        };
                        reader.readAsDataURL(blob);
                    }, 'image/png');
                }
            })
            .catch(function(err) {
                console.log("Error: " + err);
            });
        });

        document.getElementById('makeCall').addEventListener('click', function() {
            var selectedUserId = document.getElementById('userSelect').value;
            if (selectedUserId) {
                // ensure we have localStream before calling
                if (!localStream) {
                    alert('Local media not ready yet');
                    return;
                }
                var call = peer.call(selectedUserId, localStream);
                call.on('stream', function(remoteStream) {
                    remoteVideo.srcObject = remoteStream;
                });
                call.on('error', function(err){ console.error('Call error', err); });
            }
        });

        // --- Changed: store inbound connections so we can reuse them ---
        peer.on('connection', function(c) {
            // store it
            users[c.peer] = users[c.peer] || { id: c.peer };
            users[c.peer].conn = c;

            c.on('data', function(data) {
                var chatLog = document.getElementById('chatLog');
                if (typeof data === 'string') {
                    if (data.indexOf('data:image/') === 0) {
                        var image = document.createElement('img');
                        image.src = data;
                        image.style.maxWidth = '400px';
                        image.style.display = 'block';
                        chatLog.appendChild(image);
                        chatLog.innerHTML += '<br>';
                    } else {
                        chatLog.innerHTML += 'Peer: ' + data + '<br>';
                    }
                } else if (data instanceof Blob || data instanceof ArrayBuffer) {
                    var url = URL.createObjectURL(data);
                    var image = document.createElement('img');
                    image.src = url;
                    image.style.maxWidth = '400px';
                    image.style.display = 'block';
                    chatLog.appendChild(image);
                    chatLog.innerHTML += '<br>';
                } else {
                    try {
                        chatLog.innerHTML += 'Peer: ' + JSON.stringify(data) + '<br>';
                    } catch (e) {
                        chatLog.innerHTML += 'Peer sent data<br>';
                    }
                }
            });

            c.on('open', function() {
                console.log('Inbound connection open from', c.peer);
            });

            c.on('close', function() {
                console.log('Inbound connection closed from', c.peer);
                if (users[c.peer]) delete users[c.peer].conn;
            });

            c.on('error', function(err){
                console.error('Inbound connection error from', c.peer, err);
            });
         });

        navigator.mediaDevices.getUserMedia({video: true, audio: true})
        .then(function(stream) {
            localStream = stream;
        })
        .catch(function(err) {
            console.log("Error: " + err);
        });

        peer.on('call', function(call) {
            call.answer(localStream);
            call.on('stream', function(remoteStream) {
                remoteVideo.srcObject = remoteStream;
            });
        });
    </script>
    <div id="myPeerId"></div>
    <div id="chatLog"></div>
</body>
</html>
