<!DOCTYPE html>
<html>
<head>
    <title>PeerJS Chat</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <!-- <script src="./static/peerjs.min.js"></script> -->
    <!-- Add/replace styles for centered fixed-size chat box -->
	<style>
		/* Centered fixed-size chat box */
		.center-wrap { display:flex; align-items:center; justify-content:center; height:100vh; background:#e5ddd5; }
		.chat-box {
			width:720px;
			height:600px;
			background:#ffffff;
			border-radius:12px;
			box-shadow:0 6px 18px rgba(0,0,0,0.12);
			display:flex;
			flex-direction:column;
			overflow:hidden;
		}
		.chat-header {
			padding:12px 16px;
			background:#00c853;
			color:#fff;
			font-weight:600;
			display:flex;
			justify-content:space-between;
			align-items:center;
		}
		.chat-area { display:flex; flex:1; min-height:0; } /* min-height:0 needed for flexbox scroll */
		.contacts-pane {
			width:260px;
			border-right:1px solid #eee;
			overflow:auto;
			background:#fafafa;
		}
		.contacts-pane .contact { padding:10px; border-bottom:1px solid #f0f0f0; cursor:pointer; }
		.messages-pane {
			flex:1;
			display:flex;
			flex-direction:column;
			min-width:0;
		}
		.messages {
			padding:16px;
			overflow:auto;
			background:linear-gradient(180deg,#f6f6f6,#eaeaea);
			flex:1;
		}
		.input-bar {
			padding:10px;
			display:flex;
			gap:8px;
			align-items:center;
			border-top:1px solid #eee;
			background:#fff;
		}
		.input-bar textarea { flex:1; resize:none; height:48px; padding:10px; border-radius:8px; border:1px solid #ddd; font-size:14px; }
		.input-bar .file-input {
			display:inline-block;
		}
		.input-bar .btn { background:#00c853; color:#fff; padding:10px 14px; border-radius:8px; border:none; cursor:pointer; }
		/* small image in bubble */
		.msg-img { max-width:260px; border-radius:8px; display:block; }

		/* keep previous wechat-like bubble styles if present */
		.message.me { justify-content:flex-end; }
		.bubble.right { background:#00c853; color:#fff; }
		.bubble.left { background:#fff; color:#111; }
	</style>
</head>
<body>
    <!-- Replace main wechat layout with centered chat-box while preserving contacts and chat area -->
	<div class="center-wrap">
		<div class="chat-box">
			<div class="chat-header">
				<span>WeChat Lite</span>
				<small id="myPeerId">...</small>
			</div>

			<div class="chat-area">
				<!-- messages pane moved to the LEFT (user requested "on left the msg box") -->
				<div class="messages-pane">
					<div id="chatLog" class="messages"></div>

					<!-- Combined input bar: file picker + textarea + single send -->
					<div class="input-bar">
						<input id="imageInput" class="file-input" type="file" accept="image/*">
						<textarea id="messageInput" placeholder="Type a message..."></textarea>
						<button id="sendAll" class="btn">Send</button>
					</div>
				</div>

				<!-- contacts pane on the RIGHT now; includes join room + camera + call controls -->
				<div class="contacts-pane" id="contacts">
					<!-- new: join controls + camera + call inserted into contacts pane -->
					<div id="roomControls" style="padding:10px;border-bottom:1px solid #eee;">
						<input type="text" id="roomIdLeft" placeholder="Enter Room ID" style="width:100%;padding:6px;border-radius:6px;border:1px solid #ddd;margin-bottom:8px;">
						<button id="joinRoomLeft" class="btn" style="width:100%;margin-bottom:8px;">Join Room</button>

						<!-- camera select visible in the window -->
						<label for="cameraSelect" style="display:block;margin-bottom:6px;font-size:12px;color:#666;">Camera</label>
						<select id="cameraSelect" style="width:100%;padding:6px;border-radius:6px;border:1px solid #ddd;margin-bottom:8px;">
							<option value="">Default camera</option>
						</select>

						<!-- call / answer controls visible in the window -->
						<button id="makeCall" class="btn" style="width:48%;display:inline-block;margin-right:4%;">Call</button>
						<button id="answerCall" class="btn" style="width:48%;display:inline-block;display:none;">Answer</button>
					</div>

					<!-- contacts list rendered below -->
					<div id="contactsList"></div>
				</div>
			</div>
		</div>
	</div>

    <!-- changed: add playsinline and mute local preview so iOS allows autoplay -->
    <video id="localVideo" autoplay playsinline muted></video>
    <canvas id="canvas" style="display:none;"></canvas>
    <br><br>
    <!-- Removed the duplicate cameraSelect / makeCall / answerCall nodes that were previously placed after the chat-box.
     Those were removed to avoid duplicated controls. Keep the hidden local video/canvas for capture if needed. -->

    <video id="remoteVideo" autoplay playsinline></video>
    <script>
        // --- Changed: create peer with modern iceServers ("urls") and debug/error logging ---
        var peer = new Peer({
            secure: true,
            debug: 2,
            config: {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ]
            }
        });

        var roomId = null;
        var users = {};
        var conn;
        var localStream;
        var remoteVideo = document.getElementById('remoteVideo');
        var localVideo = document.getElementById('localVideo');
        var cameraSelect = document.getElementById('cameraSelect');
        var canvas = document.getElementById('canvas');
        var context = canvas.getContext('2d');

        // New: chat storage and UI helpers
		var messages = {}; // { peerId: [{text, from, isImage, me, ts}, ...] }
		var currentPeer = null;
		var refreshTimer = null;

		function appendMessage(text, from, isImage, me, peerId) {
			peerId = peerId || currentPeer;
			if (!peerId) return;
			messages[peerId] = messages[peerId] || [];
			messages[peerId].push({ text: text, from: from, isImage: !!isImage, me: !!me, ts: Date.now() });
			// only render if the chat with this peer is active
			if (peerId === currentPeer) {
				var messagesDiv = document.getElementById('chatLog');
				// render single message
				var wrapper = document.createElement('div');
				wrapper.className = 'message ' + (me ? 'me' : 'other');
				var bubble = document.createElement('div');
				bubble.className = 'bubble ' + (me ? 'right' : 'left');
				if (isImage) {
					var img = document.createElement('img');
					img.className = 'msg-img';
					img.src = text;
					bubble.appendChild(img);
				} else {
					bubble.textContent = text;
				}
				wrapper.appendChild(bubble);
				var time = document.createElement('div');
				time.className = 'msg-time';
				time.textContent = (from ? (from + ' ') : '') + new Date().toLocaleTimeString();
				wrapper.appendChild(time);
				messagesDiv.appendChild(wrapper);
				messagesDiv.scrollTop = messagesDiv.scrollHeight;
			}
		}

		function renderChat(peerId) {
			currentPeer = peerId;
			var messagesDiv = document.getElementById('chatLog');
			messagesDiv.innerHTML = '';
			if (!peerId) {
				document.getElementById('chatTitle') && (document.getElementById('chatTitle').textContent = 'Select a contact');
				return;
			}
			document.getElementById('chatTitle') && (document.getElementById('chatTitle').textContent = peerId);
			var list = messages[peerId] || [];
			list.forEach(function(m) {
				var wrapper = document.createElement('div');
				wrapper.className = 'message ' + (m.me ? 'me' : 'other');
				var bubble = document.createElement('div');
				bubble.className = 'bubble ' + (m.me ? 'right' : 'left');
				if (m.isImage) {
					var img = document.createElement('img');
					img.className = 'msg-img';
					img.src = m.text;
					bubble.appendChild(img);
				} else {
					bubble.textContent = m.text;
				}
				wrapper.appendChild(bubble);
				var time = document.createElement('div');
				time.className = 'msg-time';
				time.textContent = (m.from ? (m.from + ' ') : '') + new Date(m.ts).toLocaleTimeString();
				wrapper.appendChild(time);
				messagesDiv.appendChild(wrapper);
			});
			messagesDiv.scrollTop = messagesDiv.scrollHeight;
		}

		// Contacts rendering helpers
		var contactsListDiv = document.getElementById('contactsList');

		function renderContacts(peers) {
			contactsListDiv.innerHTML = '';
			peers.forEach(function(id) {
				if (id !== peer.id) {
					addContact(id);
					// restore selected state if this was the currentPeer
					if (currentPeer && id === currentPeer) {
						var sel = contactsListDiv.querySelector('.contact[data-id="'+id+'"]');
						if (sel) sel.classList.add('selected');
					}
				}
			});
		}

		// Replace addContact to reliably set currentPeer and support touch
		function addContact(id) {
			if (contactsListDiv.querySelector('.contact[data-id="'+id+'"]')) return;
			var el = document.createElement('div');
			el.className = 'contact';
			el.dataset.id = id;
			el.innerHTML = '<div class="avatar"></div><div class="meta"><strong>' + id + '</strong><small>Tap to chat</small></div>';

			function selectContact() {
				// highlight selection
				Array.from(contactsListDiv.children).forEach(function(c){ c.classList.remove('selected'); });
				el.classList.add('selected');

				// update hidden select (keeps existing logic compatible)
				var us = document.getElementById('userSelect');
				if (us) us.value = id;

				// authoritative selection used by sendAll and render
				currentPeer = id;
				renderChat(id);
			}

			el.addEventListener('click', selectContact);
			// touchstart improves responsiveness on mobile/touch devices
			el.addEventListener('touchstart', function(evt){
				evt.preventDefault(); // prevent 300ms delay / synthetic mouse events
				selectContact();
			}, { passive:false });

			contactsListDiv.appendChild(el);
		}

        peer.on('error', function(err) {
            console.error('Peer error:', err);
        });

        // Helper: get or create a DataConnection and reuse it (important for iOS/Safari)
        function getOrCreateConnection(userId, cb) {
            if (!userId) return;
            // reuse existing open connection
            if (users[userId] && users[userId].conn && users[userId].conn.open) {
                return cb(users[userId].conn);
            }
            // create a new connection with reliable flag (helps Safari)
            var c = peer.connect(userId, { reliable: true });
            users[userId] = users[userId] || { id: userId };
            users[userId].conn = c;

            c.on('open', function() {
                console.log('Connection open to', userId);
                cb(c);
            });

            c.on('data', function(data) {
                var peerId = c.peer;
				if (typeof data === 'string' && data.indexOf('data:image/') === 0) {
					appendMessage(data, peerId, true, false, peerId);
				} else if (typeof data === 'string') {
					appendMessage(data, peerId, false, false, peerId);
				} else if (data instanceof Blob || data instanceof ArrayBuffer) {
					var url = URL.createObjectURL(data);
					appendMessage(url, peerId, true, false, peerId);
				} else {
					try { appendMessage(JSON.stringify(data), peerId, false, false, peerId); } catch(e){ appendMessage('Peer sent data', peerId, false, false, peerId);}
				}
            });

            c.on('error', function(err) {
                console.error('Connection error with', userId, err);
            });

            c.on('close', function() {
                console.log('Connection closed to', userId);
                if (users[userId]) delete users[userId].conn;
            });
        }

        // Refresh peers from server and update UI
		function refreshPeersFromServer() {
			if (!roomId) return;
			var xhr = new XMLHttpRequest();
			xhr.open('POST', '/get_peers', true);
			xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
			xhr.send('roomId=' + encodeURIComponent(roomId));
			xhr.onload = function() {
				if (xhr.status === 200) {
					try {
						var peers = JSON.parse(xhr.responseText).peers || [];
						// update left contacts UI
						renderContacts(peers);
						// also update hidden select for backwards compatibility
						var userSelect = document.getElementById('userSelect');
						userSelect.innerHTML = '<option value="">Select a user to chat with</option>';
						peers.forEach(function(peerId) {
							if (peerId !== peer.id) {
								var option = document.createElement('option');
								option.value = peerId;
								option.text = peerId;
								userSelect.add(option);
							}
						});
					} catch (e) { console.warn('Invalid peers response', e); }
				}
			};
		}

        peer.on('open', function(id) {
            console.log('My peer ID is: ' + id);
            users[id] = users[id] || { id: id };
            addContact(id); // optional, shows self in contacts
            document.getElementById('myPeerId').innerHTML = 'My Peer ID: ' + id;
            // if already had roomId (reconnect), refresh peers
            if (roomId) { refreshPeersFromServer(); if (refreshTimer) clearInterval(refreshTimer); refreshTimer = setInterval(refreshPeersFromServer, 10000); }
        });

        document.getElementById('joinRoomLeft').addEventListener('click', function() {
			roomId = document.getElementById('roomIdLeft').value;
			if (!roomId) { alert('Enter a room id'); return; }
			var xhr = new XMLHttpRequest();
			xhr.open('POST', '/join', true);
			xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
			xhr.send('roomId=' + encodeURIComponent(roomId) + '&peerId=' + encodeURIComponent(peer.id));
			xhr.onload = function() {
				if (xhr.status === 200) {
					// start immediate refresh and periodic refresh every 10s
					refreshPeersFromServer();
					if (refreshTimer) clearInterval(refreshTimer);
					refreshTimer = setInterval(refreshPeersFromServer, 10000);
				} else {
					alert('Failed to join room');
				}
			};
		});

		// unified send: prefer currentPeer (explicitly selected contact)
		document.getElementById('sendAll').addEventListener('click', function() {
			// prefer currentPeer first
			var userId = currentPeer || (document.getElementById('userSelect') && document.getElementById('userSelect').value) || '';
			if (!userId) { alert('Select a contact to send to.'); return; }

			var imageInput = document.getElementById('imageInput');
			var messageInput = document.getElementById('messageInput');

			if (imageInput && imageInput.files && imageInput.files.length > 0) {
				var file = imageInput.files[0];
				var reader = new FileReader();
				reader.onload = function() {
					var imageData = reader.result;
					getOrCreateConnection(userId, function(conn) {
						conn.send(imageData);
						// store and render locally
						appendMessage(imageData, 'You', true, true, userId);
						imageInput.value = '';
					});
				};
				reader.readAsDataURL(file);
				return;
			}

			var message = messageInput.value && messageInput.value.trim();
			if (message) {
				getOrCreateConnection(userId, function(conn) {
					conn.send(message);
					appendMessage(message, 'You', false, true, userId);
					messageInput.value = '';
				});
			}
		});

        // New helper: request local media on demand (use user gesture)
        function ensureLocalStream(cb) {
            if (localStream) {
                // if a camera is selected that differs from current stream, recreate
                var selectedId = cameraSelect.value || null;
                var currentDeviceId = null;
                try {
                    var tracks = localStream.getVideoTracks();
                    if (tracks && tracks.length) {
                        // many browsers provide getSettings().deviceId
                        currentDeviceId = tracks[0].getSettings ? tracks[0].getSettings().deviceId : null;
                    }
                } catch (e) { currentDeviceId = null; }

                if (selectedId && currentDeviceId !== selectedId) {
                    // stop old tracks and fall through to request new stream
                    localStream.getTracks().forEach(function(t){ try{ t.stop(); }catch(e){} });
                    localStream = null;
                } else {
                    if (cb) cb(localStream);
                    // try to populate list now that permission granted
                    populateCameraList();
                    return;
                }
            }

            var selectedDeviceId = cameraSelect.value || null;
            var videoConstraints = selectedDeviceId ? { deviceId: { exact: selectedDeviceId } } : { facingMode: 'user' };

            navigator.mediaDevices.getUserMedia({ video: videoConstraints, audio: true })
            .then(function(stream) {
                localStream = stream;
                // stop previously attached srcObject tracks if any (defensive)
                try {
                    localVideo.srcObject = stream;
                    localVideo.muted = true;
                    localVideo.setAttribute('playsinline', '');
                    localVideo.play().catch(function(){ /* ignore autoplay rejection */ });
                } catch (e) {
                    console.warn('Could not set localVideo srcObject:', e);
                }
                // update camera dropdown labels now we have permission
                populateCameraList();
                if (cb) cb(stream);
            })
            .catch(function(err) {
                console.error('getUserMedia error:', err);
                alert('Camera/microphone access is required to make/answer calls.');
                if (cb) cb(null);
            });
        }

        // New: populate available video input devices into cameraSelect
        function populateCameraList() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) return;
            navigator.mediaDevices.enumerateDevices()
            .then(function(devices) {
                var videoInputs = devices.filter(function(d) { return d.kind === 'videoinput'; });
                // preserve current selection
                var current = cameraSelect.value;
                cameraSelect.innerHTML = '<option value="">Default camera</option>';
                videoInputs.forEach(function(device) {
                    var option = document.createElement('option');
                    option.value = device.deviceId;
                    // use label when available (after permission), fallback to deviceId suffix
                    option.text = device.label || ('Camera ' + (cameraSelect.length));
                    cameraSelect.add(option);
                });
                // try to restore selection
                if (current) cameraSelect.value = current;
            })
            .catch(function(err) {
                console.warn('Could not list cameras:', err);
            });
        }

        // When user changes camera selection, re-acquire stream (user gesture recommended)
        cameraSelect.addEventListener('change', function() {
            // attempt to switch camera; this will stop old tracks and request new stream
            ensureLocalStream(function(stream){
                if (!stream) {
                    console.warn('Switch camera failed or permission denied');
                }
            });
        });

        document.getElementById('makeCall').addEventListener('click', function() {
			var selectedUserId = currentPeer || (document.getElementById('userSelect') && document.getElementById('userSelect').value);
			if (!selectedUserId) {
				alert('Select a contact to call.');
				return;
			}
			ensureLocalStream(function(stream) {
				if (!stream) {
					alert('Unable to get local media');
					return;
				}
				var call = peer.call(selectedUserId, stream);
				call.on('stream', function(remoteStream) {
					try {
						remoteVideo.srcObject = remoteStream;
						remoteVideo.setAttribute('playsinline', '');
						remoteVideo.play().catch(function(){ /* ignore */ });
					} catch (e) {
						console.warn('Could not play remote stream:', e);
					}
				});
				call.on('error', function(err){ console.error('Call error', err); });
			});
        });

        // Answer incoming calls only after ensuring we have local media
        var pendingCall = null;
        var answerBtn = document.getElementById('answerCall');

        // Replace auto-answer behavior: when a call arrives, save it and show the answer button
        peer.on('call', function(call) {
            console.log('Incoming call from', call.peer);
            pendingCall = call;
            answerBtn.style.display = 'inline-block';
            // optionally notify user in UI
            document.getElementById('chatLog').innerHTML += 'Incoming call from ' + call.peer + ' â€” click Answer Call to accept<br>';
        });

        // When user clicks Answer Call, request camera/mic (user gesture) and then answer
        answerBtn.addEventListener('click', function() {
            if (!pendingCall) return;
            // ensureLocalStream will prompt in a user gesture on iOS
            ensureLocalStream(function(stream) {
                if (!stream) {
                    alert('Could not get camera/microphone.');
                    return;
                }
                try {
                    pendingCall.answer(stream);
                } catch (e) {
                    console.error('Error answering call:', e);
                }
                pendingCall.on('stream', function(remoteStream) {
                    try {
                        remoteVideo.srcObject = remoteStream;
                        remoteVideo.setAttribute('playsinline', '');
                        remoteVideo.play().catch(function(){ /* ignore */ });
                    } catch (e) {
                        console.warn('Could not play remote stream:', e);
                    }
                });
                pendingCall.on('close', function() {
                    console.log('Call closed by peer');
                });
                pendingCall.on('error', function(err){ console.error('Call error', err); });

                // clear pending call and hide button
                pendingCall = null;
                answerBtn.style.display = 'none';
            });
        });

        // --- Changed: store inbound connections so we can reuse them ---
        peer.on('connection', function(c) {
            // store it
            users[c.peer] = users[c.peer] || { id: c.peer };
            users[c.peer].conn = c;

            c.on('data', function(data) {
                var peerId = c.peer;
				if (typeof data === 'string' && data.indexOf('data:image/') === 0) {
					appendMessage(data, peerId, true, false, peerId);
				} else if (typeof data === 'string') {
					appendMessage(data, peerId, false, false, peerId);
				} else if (data instanceof Blob || data instanceof ArrayBuffer) {
					var url = URL.createObjectURL(data);
					appendMessage(url, peerId, true, false, peerId);
				} else {
					try { appendMessage(JSON.stringify(data), peerId, false, false, peerId); } catch(e){ appendMessage('Peer sent data', peerId, false, false, peerId);}
				}
				// if contact not in list yet, add it
				addContact(peerId);
            });

            c.on('open', function() {
                console.log('Inbound connection open from', c.peer);
                addContact(c.peer);
            });

            c.on('close', function() {
                console.log('Inbound connection closed from', c.peer);
                if (users[c.peer]) delete users[c.peer].conn;
            });

            c.on('error', function(err){
                console.error('Inbound connection error from', c.peer, err);
            });
        });

        // Remove any unconditional navigator.mediaDevices.getUserMedia(...) auto-call at bottom
    </script>

    <!-- ...existing footer/ placeholders ... -->
</body>
</html>
